<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AR Video Example</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      #canvas {
        width: 100%;
        height: 100%;
      }
      .button-container {
        position: absolute;

        top: 40%;
        left: 10px;
        z-index: 999;
        display: none; /* Hide the button container by default */
      } 
      .button {
        background-color: rgba(255, 255, 255, 0.5);
        padding: 10px;
        border-radius: 5px;
        cursor: pointer;
        margin-bottom: 10px;
        font-weight: bold;
    text-align: center;
    box-shadow: 0px 2px 6px rgba(0, 0, 0, 0.1);
      }
      .button:hover {
    background-color: #eeeeee;
  }
  .arrow-up::before {
    content: "\2191";
  }

  .arrow-down::before {
    content: "\2193";
  }

  .arrow-left::before {
    content: "\2190";
  }

  .arrow-right::before {
    content: "\2192";
  }


      @media only screen and (max-width: 600px) {
  .button-container {
    top: 10%;
    left:35%

  }
 
}



    
    </style>
  </head>
  <body>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ar.js/aframe/build/aframe-ar.js"></script>


    <a-scene embedded arjs="sourceType: webcam;">
      <!-- Define the image target using the image file -->
      <a-marker type="pattern" url="pattern-1_sekou.patt">
        <!-- Create a plane with the video texture -->
        <a-plane id="plane1"
          width="1"
          height="1"
          position="0 0 0"
          rotation="-90 0 0"
          material="src: #video1"
        ></a-plane>
        <div class="button-container" id="button-container-1">
          <div class="button-group">

          <div class="button" onclick="playVideo(0)">Play</div>
          <div class="button" onclick="pauseVideo(0)">Pause</div>
          <div class="button" onclick="seekVideo(0, -5)">Rewind</div>
          <div class="button" onclick="seekVideo(0, 5)">Forward</div>
          <div class="button" onclick="mutevideo(0)">Mute/unmute</div>
          </div>
          <div class="button-group">

          <div class="button" onclick="translatex(0, -0.3,'x')"><span class="arrow-left"></span></div>
          <div class="button" onclick="translatex(0, 0.3,'x')"><span class="arrow-right"></span></div>
          <div class="button" onclick="translatex(0, -0.3,'y')"><span class="arrow-down"></span></div>
          <div class="button" onclick="translatex(0, 0.3,'y')"><span class="arrow-up"></span></div>
          </div>

        </div>
      </a-marker>

      <a-marker type="pattern" url="pattern-2_naim.patt">
        <!-- Create a plane with the video texture -->
        <a-plane id="plane2"
          width="1"
          height="1"
          position="0 0 0"
          rotation="-90 0 0"
          material="src: #video2"
        ></a-plane>
        <div class="button-container" id="button-container-2">

          <div class="button-group">
          <div class="button" onclick="playVideo(1)">Play</div>
          <div class="button" onclick="pauseVideo(1)">Pause</div>
          <div class="button" onclick="seekVideo(1, -5)">Backward</div>
          <div class="button" onclick="seekVideo(1, 5)">Forward</div>
          <div class="button" onclick="mutevideo(1)">Mute/unmute</div>

          </div>
          <div class="button-group"></div>
          <div class="button" onclick="translatex(1, -0.3,'x')"><span class="arrow-left"></span></div>
          <div class="button" onclick="translatex(1, 0.3,'x')"><span class="arrow-right"></span></div>
          <div class="button" onclick="translatex(1, -0.3,'y')"><span class="arrow-down"></span></div>
          <div class="button" onclick="translatex(1, 0.3,'y')"><span class="arrow-up"></span></div>

          </div>

        </div>
      </a-marker>

      <a-marker type="pattern" url="pattern-3_juliette.patt">


        <a-plane id="plane3"
          width="1"
          height="1"
          position="0 0 0"
          rotation="-90 0 0"
          material="src: #video3"
        ></a-plane>
        <div class="button-container" id="button-container-3">
          <div class="button-group">
          <div class="button" onclick="playVideo(2)">Play</div>
          <div class="button" onclick="pauseVideo(2)">Pause</div>
          <div class="button" onclick="seekVideo(2, -5)">Backward</div>
          <div class="button" onclick="seekVideo(2, 5)">Forward</div>
          <div class="button" onclick="mutevideo(2)">Mute/unmute</div>
          </div>
          <div class="button-group">
          <div class="button" onclick="translatex(2, -0.3,'x')"><span class="arrow-left"></span></div>
          <div class="button" onclick="translatex(2, 0.3,'x')"><span class="arrow-right"></span></div>
          <div class="button" onclick="translatex(2, -0.3,'y')"><span class="arrow-down"></span></div>
          <div class="button" onclick="translatex(2, 0.3,'y')"><span class="arrow-up"></span></div>
          </div>
        </div>
      </a-marker>
      <!--  video elements -->
      <video id="video1" src="1_sekou.mp4"></video>
      <video id="video2" src="2_naim.mp4"></video>
      <video id="video3" src="3_juliette.mp4"></video>

      <!-- Set up the camera and renderer -->
      <a-entity camera></a-entity>
    </a-scene>

    <script>


///////
AFRAME.registerComponent("gesture-handler", {
        schema: {
          enabled: { default: true },
        },

        init: function () {
          this.isVisible = true;
          this.initialScale = this.el.object3D.scale.clone();
          this.scaleFactor = 1;
          this.handleScale = this.handleScale.bind(this);
          this.toggleVisibility = this.toggleVisibility.bind(this);
          this.el.sceneEl.addEventListener("markerFound", this.toggleVisibility);
          this.el.sceneEl.addEventListener(
            "markerLost",
            this.toggleVisibility
          );
        },

        update: function () {
          if (this.data.enabled) {
            this.el.sceneEl.addEventListener("onefingermove", this.handleScale);
          } else {
            this.el.sceneEl.removeEventListener(
              "onefingermove",
              this.handleScale
            );
          }
        },

        remove: function () {
          this.el.sceneEl.removeEventListener(
            "markerFound",
            this.toggleVisibility
          );
          this.el.sceneEl.removeEventListener(
            "markerLost",
            this.toggleVisibility
          );
          this.el.sceneEl.removeEventListener(
            "onefingermove",
            this.handleScale
          );
        },

        handleScale: function (event) {
          if (event.detail.state === "move") {
            this.el.object3D.scale.x = this.initialScale.x * event.detail.scale;
            this.el.object3D.scale.y = this.initialScale.y * event.detail.scale;
            this.el.object3D.scale.z = this.initialScale.z * event.detail.scale;
          }
        },

        toggleVisibility: function () {
          this.isVisible = !this.isVisible;
          this.el.object3D.visible = this.isVisible;
        },
      });

      // Code for gesture detection

      AFRAME.registerComponent("gesture-detector", {
        schema: {
          element: { default: "" },
        },

        init: function () {
          this.targetElement =
            this.data.element && document.querySelector(this.data.element);
          if (!this.targetElement) {
            this.targetElement = this.el;
          }
          this.internalState = {
            previousState: null,
          };
          this.emitGestureEvent = this.emitGestureEvent.bind(this);
          this.targetElement.addEventListener("touchstart", this.emitGestureEvent);
          this.targetElement.addEventListener("touchend", this.emitGestureEvent);
          this.targetElement.addEventListener("touchmove", this.emitGestureEvent);
        },

        remove: function () {
          this.targetElement.removeEventListener(
            "touchstart",
            this.emitGestureEvent
          );
          this.targetElement.removeEventListener(
            "touchend",
            this.emitGestureEvent
          );
          this.targetElement.removeEventListener(
            "touchmove",
            this.emitGestureEvent
          );
        },

        emitGestureEvent: function (event) {
          const currentState = this.getTouchState(event);
          const previousState = this.internalState.previousState;

          const gestureContinues =
            previousState &&
            currentState &&
            currentState.touchCount === previousState.touchCount;

          const gestureEnded = previousState && !gestureContinues;

          const gestureStarted = currentState && !gestureContinues;

          if (gestureEnded) {
            const eventName =
              this.getEventPrefix(previousState.touchCount) + "fingerend";
            this.el.emit(eventName, previousState);
            this.internalState.previousState = null;
          }

          if (gestureStarted) {
            currentState.startTime = performance.now();
            currentState.startPosition = currentState.position;
            currentState.startSpread = currentState.spread;
            currentState.startAngle = currentState.angle;
            const eventName =
              this.getEventPrefix(currentState.touchCount) + "fingerstart";
            this.el.emit(eventName, currentState);
            this.internalState.previousState = currentState;
          }

          if (gestureContinues) {
            const eventDetail = {
              positionChange: {
                x: currentState.position.x - previousState.position.x,
                y: currentState.position.y - previousState.position.y,
              },
            };

            if (currentState.spread && previousState.spread) {
              eventDetail.scale = currentState.spread / previousState.spread;
            }

            if (currentState.angle && previousState.angle) {
              eventDetail.rotation =
                currentState.angle - previousState.angle;
            }

            // Update state with new data
            Object.assign(previousState, currentState);

            // Add state data to event detail
            Object.assign(eventDetail, previousState);

            const eventName =
              this.getEventPrefix(currentState.touchCount) + "fingermove";
            this.el.emit(eventName, eventDetail);
          }
        },

        getTouchState: function (event) {
          if (event.touches.length === 0) {
            return null;
          }

          // Convert event.touches to an array so we can use reduce
          const touchList = [];
          for (let i = 0; i < event.touches.length; i++) {
            touchList.push(event.touches[i]);
          }

          const touchState = {
            touchCount: touchList.length,
          };

          // Calculate center of all current touches
          const centerPositionRawX =
            touchList.reduce((sum, touch) => sum + touch.clientX, 0) /
            touchList.length;
          const centerPositionRawY =
            touchList.reduce((sum, touch) => sum + touch.clientY, 0) /
            touchList.length;

          touchState.positionRaw = { x: centerPositionRawX, y: centerPositionRawY };

          // Scale touch position and spread by average of window dimensions
          const screenScaleFactor =
            2 / (window.innerWidth + window.innerHeight);
          touchState.position = {
            x: touchState.positionRaw.x * screenScaleFactor,
            y: touchState.positionRaw.y * screenScaleFactor,
          };

          // Calculate average spread of touches from the center point
          if (touchList.length >= 2) {
            const spread =
              touchList.reduce((sum, touch) => {
                return (
                  sum +
                  Math.sqrt(
                    Math.pow(centerPositionRawX - touch.clientX, 2) +
                      Math.pow(centerPositionRawY - touch.clientY, 2)
                  )
                );
              }, 0) / touchList.length;

            touchState.spread = spread * screenScaleFactor;
          }

          // Calculate rotation from first two touches
          if (touchList.length >= 2) {
            const angle =
              Math.atan2(
                touchList[1].clientY - touchList[0].clientY,
                touchList[1].clientX - touchList[0].clientX
              ) *
              (180 / Math.PI);

            touchState.angle = angle;
          }

          return touchState;
        },

        getEventPrefix: function (fingerCount) {
          const numberNames = ["one", "two", "three", "four", "five"];
          return numberNames[fingerCount - 1];
        },
      });
/////////
      document.addEventListener("DOMContentLoaded", function () {
        const markers = document.querySelectorAll("a-marker");

        markers.forEach((marker, index) => {
          const buttonContainer = document.getElementById(
            `button-container-${index + 1}`
          );
          const video = document.getElementById(`video${index + 1}`);

          marker.addEventListener("markerFound", function () {
            buttonContainer.style.display = "block"; // Show the button container
            console.log("marker found");
            video.play();
          });

          marker.addEventListener("markerLost", function () {
            buttonContainer.style.display = "none"; // Hide the button container
            video.pause();
            video.currentTime = 0;
          });
        });
      });

      // Functions to control the videos
      function playVideo(index) {
        const video = document.getElementById(`video${index + 1}`);
        video.play();
      }

      function pauseVideo(index) {
        const video = document.getElementById(`video${index + 1}`);
        video.pause();
      }

 
      function seekVideo(index, time) {
        const video = document.getElementById(`video${index + 1}`);
        video.currentTime += time;
      }
      function mutevideo(index) {
        const video = document.getElementById(`video${index + 1}`);
        if (video.muted == true) video.muted = false
        else
        video.muted = true;
      }
      function translatex(index,i,axe){
        const video = document.getElementById(`plane${index + 1}`);
       if(axe == 'x') video.object3D.translateX(i)
       else video.object3D.translateY(i);

        console.log("position:", video.object3D.position);
       
       
      }
    </script>
  </body>
</html>
